#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <stdbool.h>

#define WORK_DIR "/"
#define THREADS 10


typedef struct s_data
{
    pthread_mutex_t mutex;
    int counter;
    bool flag;
}               t_data;


void print_hello(t_data *data)
{
    pthread_mutex_lock(&data->mutex);
    if (data->flag)
        write(1,"\n",1 );
    printf("Hello word its thread #%d\n", data->counter);
    pthread_mutex_unlock(&data->mutex);
}

void daemonize()
{   
    srand(time(NULL));
    pid_t   process_id = 0;
    pid_t   sid = 0;
    pthread_t threads[THREADS];
    int r_amount = rand() % 100;
    t_data *dataptr = (t_data *)malloc(sizeof(t_data));
 
    while(r_amount-- > 0){
        pthread_mutex_init(&dataptr->mutex, NULL);

        for(int i = 0; i < THREADS; i++){
            dataptr->counter = i;
            dataptr->flag =  (i + 1) < THREADS ? false : true;
            pthread_create(&threads[i], NULL, (void *)print_hello, dataptr);
        }
        for(int i = 0; i < THREADS; ++i)
            pthread_join(threads[i], NULL);
        pthread_mutex_destroy(&dataptr->mutex);
    }
    free(dataptr);

    process_id = fork();
    if (process_id < 0){
        printf("error: cant fork\n");
        exit(EXIT_FAILURE);
    }
    sid = setsid(); //new session for child process
    if (sid  < 0)
        exit (EXIT_FAILURE);
    umask(0); // full access to the files generated by the daemon
    /* Change the current working directory */
    if ((chdir(WORK_DIR)) < 0) 
        exit(EXIT_FAILURE);
    close(STDERR_FILENO);
    close(STDIN_FILENO);
    close(STDOUT_FILENO);

}

int main()
{
    daemonize();
    while(1)
        sleep(0);
    return 0;
}
